import sys
input = sys.stdin.readline

# N, M 입력 받아 2차원 배열 생성
n, m = map(int, input().split()) #
board = [list(map(int, input().split())) for _ in range(n)]

# 5가지 종류의 테트로미노의 대칭, 회전까지 고려한 19가지의 테트로미노 정의
tetromino_shapes = [
    # I자
    [(0,0), (0,1), (0,2), (0,3)],
    [(0,0), (1,0), (2,0), (3,0)],
    # O자 (정사각형)
    [(0,0), (0,1), (1,0), (1,1)],
    # L자 및 대칭 회전들
    [(0,0), (1,0), (2,0), (2,1)],
    [(0,0), (0,1), (1,1), (2,1)],
    [(0,0), (0,1), (0,2), (1,0)],
    [(0,0), (1,0), (1,1), (1,2)],
    [(0,0), (0,1), (1,1), (1,2)],
    [(0,0), (1,0), (1,-1), (2,-1)],
    [(0,0), (0,1), (0,2), (-1,1)],
    [(0,0), (1,0), (2,0), (1,1)],
    [(0,0), (1,0), (1,1), (2,0)],
    [(0,0), (0,1), (0,2), (1,1)],
    # Z자 및 대칭 회전들
    [(0,0), (0,1), (1,0), (0,2)],
    [(0,0), (0,1), (1,1), (2,1)],
    [(0,0), (1,0), (1,1), (2,1)],
    [(0,0), (1,0), (2,0), (2,-1)],
    # ㅗ자 모양들
    [(0,0), (0,1), (1,1), (1,2)],
    [(0,0), (0,1), (1,0), (1,-1)],
]

# 최댓값 저장용 변수
max_sum = 0

# 전체 보드의 각 위치(i, j)를 기준으로 테트로미노를 하나씩 올려보며 확인
for i in range(n):
    for j in range(m):
        for shape in tetromino_shapes:
            try:
                total = 0 # 현재 모양으로 계산한 합
                for dx, dy in shape:
                    ni, nj = i + dx, j + dy # 실제 좌표 계산
                    if 0 <= ni < n and 0 <= nj < m:
                        total += board[ni][nj] # 유효하면 합산
                    else:
                        raise IndexError # 보드 범위 벗어나면 예외 발생
                max_sum = max(max_sum, total) # 최댓값 갱신
            except IndexError:
                continue # 범위를 벗어난 테트로미노는 건너뛰기

# 최종 결과 출력
print(max_sum)